// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package usecases

import (
	"context"
	"time"

	"github.com/AzimBB/go-chat-app-backend/internal/domain/entities"
	mock "github.com/stretchr/testify/mock"
)

// NewMockCache creates a new instance of MockCache. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockCache(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockCache {
	mock := &MockCache{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockCache is an autogenerated mock type for the Cache type
type MockCache struct {
	mock.Mock
}

type MockCache_Expecter struct {
	mock *mock.Mock
}

func (_m *MockCache) EXPECT() *MockCache_Expecter {
	return &MockCache_Expecter{mock: &_m.Mock}
}

// GetSessionByID provides a mock function for the type MockCache
func (_mock *MockCache) GetSessionByID(ctx context.Context, id string) (entities.Session, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetSessionByID")
	}

	var r0 entities.Session
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (entities.Session, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) entities.Session); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(entities.Session)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockCache_GetSessionByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSessionByID'
type MockCache_GetSessionByID_Call struct {
	*mock.Call
}

// GetSessionByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockCache_Expecter) GetSessionByID(ctx interface{}, id interface{}) *MockCache_GetSessionByID_Call {
	return &MockCache_GetSessionByID_Call{Call: _e.mock.On("GetSessionByID", ctx, id)}
}

func (_c *MockCache_GetSessionByID_Call) Run(run func(ctx context.Context, id string)) *MockCache_GetSessionByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockCache_GetSessionByID_Call) Return(session entities.Session, err error) *MockCache_GetSessionByID_Call {
	_c.Call.Return(session, err)
	return _c
}

func (_c *MockCache_GetSessionByID_Call) RunAndReturn(run func(ctx context.Context, id string) (entities.Session, error)) *MockCache_GetSessionByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserFromCache provides a mock function for the type MockCache
func (_mock *MockCache) GetUserFromCache(ctx context.Context, key string) (entities.User, error) {
	ret := _mock.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for GetUserFromCache")
	}

	var r0 entities.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (entities.User, error)); ok {
		return returnFunc(ctx, key)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) entities.User); ok {
		r0 = returnFunc(ctx, key)
	} else {
		r0 = ret.Get(0).(entities.User)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, key)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockCache_GetUserFromCache_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserFromCache'
type MockCache_GetUserFromCache_Call struct {
	*mock.Call
}

// GetUserFromCache is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockCache_Expecter) GetUserFromCache(ctx interface{}, key interface{}) *MockCache_GetUserFromCache_Call {
	return &MockCache_GetUserFromCache_Call{Call: _e.mock.On("GetUserFromCache", ctx, key)}
}

func (_c *MockCache_GetUserFromCache_Call) Run(run func(ctx context.Context, key string)) *MockCache_GetUserFromCache_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockCache_GetUserFromCache_Call) Return(user entities.User, err error) *MockCache_GetUserFromCache_Call {
	_c.Call.Return(user, err)
	return _c
}

func (_c *MockCache_GetUserFromCache_Call) RunAndReturn(run func(ctx context.Context, key string) (entities.User, error)) *MockCache_GetUserFromCache_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveFromCacheByKey provides a mock function for the type MockCache
func (_mock *MockCache) RemoveFromCacheByKey(ctx context.Context, link string) error {
	ret := _mock.Called(ctx, link)

	if len(ret) == 0 {
		panic("no return value specified for RemoveFromCacheByKey")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, link)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockCache_RemoveFromCacheByKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveFromCacheByKey'
type MockCache_RemoveFromCacheByKey_Call struct {
	*mock.Call
}

// RemoveFromCacheByKey is a helper method to define mock.On call
//   - ctx context.Context
//   - link string
func (_e *MockCache_Expecter) RemoveFromCacheByKey(ctx interface{}, link interface{}) *MockCache_RemoveFromCacheByKey_Call {
	return &MockCache_RemoveFromCacheByKey_Call{Call: _e.mock.On("RemoveFromCacheByKey", ctx, link)}
}

func (_c *MockCache_RemoveFromCacheByKey_Call) Run(run func(ctx context.Context, link string)) *MockCache_RemoveFromCacheByKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockCache_RemoveFromCacheByKey_Call) Return(err error) *MockCache_RemoveFromCacheByKey_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockCache_RemoveFromCacheByKey_Call) RunAndReturn(run func(ctx context.Context, link string) error) *MockCache_RemoveFromCacheByKey_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveSessionByID provides a mock function for the type MockCache
func (_mock *MockCache) RemoveSessionByID(ctx context.Context, id string) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for RemoveSessionByID")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockCache_RemoveSessionByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveSessionByID'
type MockCache_RemoveSessionByID_Call struct {
	*mock.Call
}

// RemoveSessionByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockCache_Expecter) RemoveSessionByID(ctx interface{}, id interface{}) *MockCache_RemoveSessionByID_Call {
	return &MockCache_RemoveSessionByID_Call{Call: _e.mock.On("RemoveSessionByID", ctx, id)}
}

func (_c *MockCache_RemoveSessionByID_Call) Run(run func(ctx context.Context, id string)) *MockCache_RemoveSessionByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockCache_RemoveSessionByID_Call) Return(err error) *MockCache_RemoveSessionByID_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockCache_RemoveSessionByID_Call) RunAndReturn(run func(ctx context.Context, id string) error) *MockCache_RemoveSessionByID_Call {
	_c.Call.Return(run)
	return _c
}

// SaveSession provides a mock function for the type MockCache
func (_mock *MockCache) SaveSession(ctx context.Context, session entities.Session) error {
	ret := _mock.Called(ctx, session)

	if len(ret) == 0 {
		panic("no return value specified for SaveSession")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, entities.Session) error); ok {
		r0 = returnFunc(ctx, session)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockCache_SaveSession_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SaveSession'
type MockCache_SaveSession_Call struct {
	*mock.Call
}

// SaveSession is a helper method to define mock.On call
//   - ctx context.Context
//   - session entities.Session
func (_e *MockCache_Expecter) SaveSession(ctx interface{}, session interface{}) *MockCache_SaveSession_Call {
	return &MockCache_SaveSession_Call{Call: _e.mock.On("SaveSession", ctx, session)}
}

func (_c *MockCache_SaveSession_Call) Run(run func(ctx context.Context, session entities.Session)) *MockCache_SaveSession_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 entities.Session
		if args[1] != nil {
			arg1 = args[1].(entities.Session)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockCache_SaveSession_Call) Return(err error) *MockCache_SaveSession_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockCache_SaveSession_Call) RunAndReturn(run func(ctx context.Context, session entities.Session) error) *MockCache_SaveSession_Call {
	_c.Call.Return(run)
	return _c
}

// SaveUserInCache provides a mock function for the type MockCache
func (_mock *MockCache) SaveUserInCache(ctx context.Context, key string, user entities.User, duration time.Duration) error {
	ret := _mock.Called(ctx, key, user, duration)

	if len(ret) == 0 {
		panic("no return value specified for SaveUserInCache")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, entities.User, time.Duration) error); ok {
		r0 = returnFunc(ctx, key, user, duration)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockCache_SaveUserInCache_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SaveUserInCache'
type MockCache_SaveUserInCache_Call struct {
	*mock.Call
}

// SaveUserInCache is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - user entities.User
//   - duration time.Duration
func (_e *MockCache_Expecter) SaveUserInCache(ctx interface{}, key interface{}, user interface{}, duration interface{}) *MockCache_SaveUserInCache_Call {
	return &MockCache_SaveUserInCache_Call{Call: _e.mock.On("SaveUserInCache", ctx, key, user, duration)}
}

func (_c *MockCache_SaveUserInCache_Call) Run(run func(ctx context.Context, key string, user entities.User, duration time.Duration)) *MockCache_SaveUserInCache_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 entities.User
		if args[2] != nil {
			arg2 = args[2].(entities.User)
		}
		var arg3 time.Duration
		if args[3] != nil {
			arg3 = args[3].(time.Duration)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockCache_SaveUserInCache_Call) Return(err error) *MockCache_SaveUserInCache_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockCache_SaveUserInCache_Call) RunAndReturn(run func(ctx context.Context, key string, user entities.User, duration time.Duration) error) *MockCache_SaveUserInCache_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockUserRepository creates a new instance of MockUserRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUserRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUserRepository {
	mock := &MockUserRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockUserRepository is an autogenerated mock type for the UserRepository type
type MockUserRepository struct {
	mock.Mock
}

type MockUserRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockUserRepository) EXPECT() *MockUserRepository_Expecter {
	return &MockUserRepository_Expecter{mock: &_m.Mock}
}

// CheckEmailExistence provides a mock function for the type MockUserRepository
func (_mock *MockUserRepository) CheckEmailExistence(ctx context.Context, email string) error {
	ret := _mock.Called(ctx, email)

	if len(ret) == 0 {
		panic("no return value specified for CheckEmailExistence")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, email)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockUserRepository_CheckEmailExistence_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckEmailExistence'
type MockUserRepository_CheckEmailExistence_Call struct {
	*mock.Call
}

// CheckEmailExistence is a helper method to define mock.On call
//   - ctx context.Context
//   - email string
func (_e *MockUserRepository_Expecter) CheckEmailExistence(ctx interface{}, email interface{}) *MockUserRepository_CheckEmailExistence_Call {
	return &MockUserRepository_CheckEmailExistence_Call{Call: _e.mock.On("CheckEmailExistence", ctx, email)}
}

func (_c *MockUserRepository_CheckEmailExistence_Call) Run(run func(ctx context.Context, email string)) *MockUserRepository_CheckEmailExistence_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUserRepository_CheckEmailExistence_Call) Return(err error) *MockUserRepository_CheckEmailExistence_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockUserRepository_CheckEmailExistence_Call) RunAndReturn(run func(ctx context.Context, email string) error) *MockUserRepository_CheckEmailExistence_Call {
	_c.Call.Return(run)
	return _c
}

// CheckPassword provides a mock function for the type MockUserRepository
func (_mock *MockUserRepository) CheckPassword(ctx context.Context, email string, password string) error {
	ret := _mock.Called(ctx, email, password)

	if len(ret) == 0 {
		panic("no return value specified for CheckPassword")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = returnFunc(ctx, email, password)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockUserRepository_CheckPassword_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckPassword'
type MockUserRepository_CheckPassword_Call struct {
	*mock.Call
}

// CheckPassword is a helper method to define mock.On call
//   - ctx context.Context
//   - email string
//   - password string
func (_e *MockUserRepository_Expecter) CheckPassword(ctx interface{}, email interface{}, password interface{}) *MockUserRepository_CheckPassword_Call {
	return &MockUserRepository_CheckPassword_Call{Call: _e.mock.On("CheckPassword", ctx, email, password)}
}

func (_c *MockUserRepository_CheckPassword_Call) Run(run func(ctx context.Context, email string, password string)) *MockUserRepository_CheckPassword_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockUserRepository_CheckPassword_Call) Return(err error) *MockUserRepository_CheckPassword_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockUserRepository_CheckPassword_Call) RunAndReturn(run func(ctx context.Context, email string, password string) error) *MockUserRepository_CheckPassword_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function for the type MockUserRepository
func (_mock *MockUserRepository) Create(ctx context.Context, user *entities.User) error {
	ret := _mock.Called(ctx, user)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *entities.User) error); ok {
		r0 = returnFunc(ctx, user)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockUserRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockUserRepository_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - user *entities.User
func (_e *MockUserRepository_Expecter) Create(ctx interface{}, user interface{}) *MockUserRepository_Create_Call {
	return &MockUserRepository_Create_Call{Call: _e.mock.On("Create", ctx, user)}
}

func (_c *MockUserRepository_Create_Call) Run(run func(ctx context.Context, user *entities.User)) *MockUserRepository_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *entities.User
		if args[1] != nil {
			arg1 = args[1].(*entities.User)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUserRepository_Create_Call) Return(err error) *MockUserRepository_Create_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockUserRepository_Create_Call) RunAndReturn(run func(ctx context.Context, user *entities.User) error) *MockUserRepository_Create_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserIDByEmail provides a mock function for the type MockUserRepository
func (_mock *MockUserRepository) GetUserIDByEmail(ctx context.Context, email string) (string, error) {
	ret := _mock.Called(ctx, email)

	if len(ret) == 0 {
		panic("no return value specified for GetUserIDByEmail")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (string, error)); ok {
		return returnFunc(ctx, email)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = returnFunc(ctx, email)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, email)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserRepository_GetUserIDByEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserIDByEmail'
type MockUserRepository_GetUserIDByEmail_Call struct {
	*mock.Call
}

// GetUserIDByEmail is a helper method to define mock.On call
//   - ctx context.Context
//   - email string
func (_e *MockUserRepository_Expecter) GetUserIDByEmail(ctx interface{}, email interface{}) *MockUserRepository_GetUserIDByEmail_Call {
	return &MockUserRepository_GetUserIDByEmail_Call{Call: _e.mock.On("GetUserIDByEmail", ctx, email)}
}

func (_c *MockUserRepository_GetUserIDByEmail_Call) Run(run func(ctx context.Context, email string)) *MockUserRepository_GetUserIDByEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUserRepository_GetUserIDByEmail_Call) Return(userID string, err error) *MockUserRepository_GetUserIDByEmail_Call {
	_c.Call.Return(userID, err)
	return _c
}

func (_c *MockUserRepository_GetUserIDByEmail_Call) RunAndReturn(run func(ctx context.Context, email string) (string, error)) *MockUserRepository_GetUserIDByEmail_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockMailingService creates a new instance of MockMailingService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockMailingService(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockMailingService {
	mock := &MockMailingService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockMailingService is an autogenerated mock type for the MailingService type
type MockMailingService struct {
	mock.Mock
}

type MockMailingService_Expecter struct {
	mock *mock.Mock
}

func (_m *MockMailingService) EXPECT() *MockMailingService_Expecter {
	return &MockMailingService_Expecter{mock: &_m.Mock}
}

// SendActivationLink provides a mock function for the type MockMailingService
func (_mock *MockMailingService) SendActivationLink(ctx context.Context, email string, activationCode string) error {
	ret := _mock.Called(ctx, email, activationCode)

	if len(ret) == 0 {
		panic("no return value specified for SendActivationLink")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = returnFunc(ctx, email, activationCode)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockMailingService_SendActivationLink_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendActivationLink'
type MockMailingService_SendActivationLink_Call struct {
	*mock.Call
}

// SendActivationLink is a helper method to define mock.On call
//   - ctx context.Context
//   - email string
//   - activationCode string
func (_e *MockMailingService_Expecter) SendActivationLink(ctx interface{}, email interface{}, activationCode interface{}) *MockMailingService_SendActivationLink_Call {
	return &MockMailingService_SendActivationLink_Call{Call: _e.mock.On("SendActivationLink", ctx, email, activationCode)}
}

func (_c *MockMailingService_SendActivationLink_Call) Run(run func(ctx context.Context, email string, activationCode string)) *MockMailingService_SendActivationLink_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockMailingService_SendActivationLink_Call) Return(err error) *MockMailingService_SendActivationLink_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockMailingService_SendActivationLink_Call) RunAndReturn(run func(ctx context.Context, email string, activationCode string) error) *MockMailingService_SendActivationLink_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockJWTService creates a new instance of MockJWTService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockJWTService(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockJWTService {
	mock := &MockJWTService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockJWTService is an autogenerated mock type for the JWTService type
type MockJWTService struct {
	mock.Mock
}

type MockJWTService_Expecter struct {
	mock *mock.Mock
}

func (_m *MockJWTService) EXPECT() *MockJWTService_Expecter {
	return &MockJWTService_Expecter{mock: &_m.Mock}
}

// CreateSession provides a mock function for the type MockJWTService
func (_mock *MockJWTService) CreateSession(ctx context.Context, userID string, refreshToken string, userAgent string, ClientIP string) (entities.Session, error) {
	ret := _mock.Called(ctx, userID, refreshToken, userAgent, ClientIP)

	if len(ret) == 0 {
		panic("no return value specified for CreateSession")
	}

	var r0 entities.Session
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string, string) (entities.Session, error)); ok {
		return returnFunc(ctx, userID, refreshToken, userAgent, ClientIP)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, string, string) entities.Session); ok {
		r0 = returnFunc(ctx, userID, refreshToken, userAgent, ClientIP)
	} else {
		r0 = ret.Get(0).(entities.Session)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, string, string) error); ok {
		r1 = returnFunc(ctx, userID, refreshToken, userAgent, ClientIP)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockJWTService_CreateSession_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateSession'
type MockJWTService_CreateSession_Call struct {
	*mock.Call
}

// CreateSession is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - refreshToken string
//   - userAgent string
//   - ClientIP string
func (_e *MockJWTService_Expecter) CreateSession(ctx interface{}, userID interface{}, refreshToken interface{}, userAgent interface{}, ClientIP interface{}) *MockJWTService_CreateSession_Call {
	return &MockJWTService_CreateSession_Call{Call: _e.mock.On("CreateSession", ctx, userID, refreshToken, userAgent, ClientIP)}
}

func (_c *MockJWTService_CreateSession_Call) Run(run func(ctx context.Context, userID string, refreshToken string, userAgent string, ClientIP string)) *MockJWTService_CreateSession_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockJWTService_CreateSession_Call) Return(session entities.Session, err error) *MockJWTService_CreateSession_Call {
	_c.Call.Return(session, err)
	return _c
}

func (_c *MockJWTService_CreateSession_Call) RunAndReturn(run func(ctx context.Context, userID string, refreshToken string, userAgent string, ClientIP string) (entities.Session, error)) *MockJWTService_CreateSession_Call {
	_c.Call.Return(run)
	return _c
}

// GenerateActivationLink provides a mock function for the type MockJWTService
func (_mock *MockJWTService) GenerateActivationLink(ctx context.Context) string {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GenerateActivationLink")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func(context.Context) string); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// MockJWTService_GenerateActivationLink_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GenerateActivationLink'
type MockJWTService_GenerateActivationLink_Call struct {
	*mock.Call
}

// GenerateActivationLink is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockJWTService_Expecter) GenerateActivationLink(ctx interface{}) *MockJWTService_GenerateActivationLink_Call {
	return &MockJWTService_GenerateActivationLink_Call{Call: _e.mock.On("GenerateActivationLink", ctx)}
}

func (_c *MockJWTService_GenerateActivationLink_Call) Run(run func(ctx context.Context)) *MockJWTService_GenerateActivationLink_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockJWTService_GenerateActivationLink_Call) Return(link string) *MockJWTService_GenerateActivationLink_Call {
	_c.Call.Return(link)
	return _c
}

func (_c *MockJWTService_GenerateActivationLink_Call) RunAndReturn(run func(ctx context.Context) string) *MockJWTService_GenerateActivationLink_Call {
	_c.Call.Return(run)
	return _c
}

// GenerateTokenPair provides a mock function for the type MockJWTService
func (_mock *MockJWTService) GenerateTokenPair(ctx context.Context, userID string) (string, string, error) {
	ret := _mock.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for GenerateTokenPair")
	}

	var r0 string
	var r1 string
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (string, string, error)); ok {
		return returnFunc(ctx, userID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = returnFunc(ctx, userID)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) string); ok {
		r1 = returnFunc(ctx, userID)
	} else {
		r1 = ret.Get(1).(string)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string) error); ok {
		r2 = returnFunc(ctx, userID)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockJWTService_GenerateTokenPair_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GenerateTokenPair'
type MockJWTService_GenerateTokenPair_Call struct {
	*mock.Call
}

// GenerateTokenPair is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *MockJWTService_Expecter) GenerateTokenPair(ctx interface{}, userID interface{}) *MockJWTService_GenerateTokenPair_Call {
	return &MockJWTService_GenerateTokenPair_Call{Call: _e.mock.On("GenerateTokenPair", ctx, userID)}
}

func (_c *MockJWTService_GenerateTokenPair_Call) Run(run func(ctx context.Context, userID string)) *MockJWTService_GenerateTokenPair_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockJWTService_GenerateTokenPair_Call) Return(accessToken string, refreshToken string, err error) *MockJWTService_GenerateTokenPair_Call {
	_c.Call.Return(accessToken, refreshToken, err)
	return _c
}

func (_c *MockJWTService_GenerateTokenPair_Call) RunAndReturn(run func(ctx context.Context, userID string) (string, string, error)) *MockJWTService_GenerateTokenPair_Call {
	_c.Call.Return(run)
	return _c
}

// ValidateAccessToken provides a mock function for the type MockJWTService
func (_mock *MockJWTService) ValidateAccessToken(ctx context.Context, accessToken string) (string, string, error) {
	ret := _mock.Called(ctx, accessToken)

	if len(ret) == 0 {
		panic("no return value specified for ValidateAccessToken")
	}

	var r0 string
	var r1 string
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (string, string, error)); ok {
		return returnFunc(ctx, accessToken)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = returnFunc(ctx, accessToken)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) string); ok {
		r1 = returnFunc(ctx, accessToken)
	} else {
		r1 = ret.Get(1).(string)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string) error); ok {
		r2 = returnFunc(ctx, accessToken)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockJWTService_ValidateAccessToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidateAccessToken'
type MockJWTService_ValidateAccessToken_Call struct {
	*mock.Call
}

// ValidateAccessToken is a helper method to define mock.On call
//   - ctx context.Context
//   - accessToken string
func (_e *MockJWTService_Expecter) ValidateAccessToken(ctx interface{}, accessToken interface{}) *MockJWTService_ValidateAccessToken_Call {
	return &MockJWTService_ValidateAccessToken_Call{Call: _e.mock.On("ValidateAccessToken", ctx, accessToken)}
}

func (_c *MockJWTService_ValidateAccessToken_Call) Run(run func(ctx context.Context, accessToken string)) *MockJWTService_ValidateAccessToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockJWTService_ValidateAccessToken_Call) Return(sessionID string, userID string, err error) *MockJWTService_ValidateAccessToken_Call {
	_c.Call.Return(sessionID, userID, err)
	return _c
}

func (_c *MockJWTService_ValidateAccessToken_Call) RunAndReturn(run func(ctx context.Context, accessToken string) (string, string, error)) *MockJWTService_ValidateAccessToken_Call {
	_c.Call.Return(run)
	return _c
}

// ValidateRefreshToken provides a mock function for the type MockJWTService
func (_mock *MockJWTService) ValidateRefreshToken(ctx context.Context, refreshToken string) (string, string, error) {
	ret := _mock.Called(ctx, refreshToken)

	if len(ret) == 0 {
		panic("no return value specified for ValidateRefreshToken")
	}

	var r0 string
	var r1 string
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (string, string, error)); ok {
		return returnFunc(ctx, refreshToken)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = returnFunc(ctx, refreshToken)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) string); ok {
		r1 = returnFunc(ctx, refreshToken)
	} else {
		r1 = ret.Get(1).(string)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string) error); ok {
		r2 = returnFunc(ctx, refreshToken)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockJWTService_ValidateRefreshToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidateRefreshToken'
type MockJWTService_ValidateRefreshToken_Call struct {
	*mock.Call
}

// ValidateRefreshToken is a helper method to define mock.On call
//   - ctx context.Context
//   - refreshToken string
func (_e *MockJWTService_Expecter) ValidateRefreshToken(ctx interface{}, refreshToken interface{}) *MockJWTService_ValidateRefreshToken_Call {
	return &MockJWTService_ValidateRefreshToken_Call{Call: _e.mock.On("ValidateRefreshToken", ctx, refreshToken)}
}

func (_c *MockJWTService_ValidateRefreshToken_Call) Run(run func(ctx context.Context, refreshToken string)) *MockJWTService_ValidateRefreshToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockJWTService_ValidateRefreshToken_Call) Return(sessionID string, userID string, err error) *MockJWTService_ValidateRefreshToken_Call {
	_c.Call.Return(sessionID, userID, err)
	return _c
}

func (_c *MockJWTService_ValidateRefreshToken_Call) RunAndReturn(run func(ctx context.Context, refreshToken string) (string, string, error)) *MockJWTService_ValidateRefreshToken_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockLogger creates a new instance of MockLogger. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockLogger(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockLogger {
	mock := &MockLogger{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockLogger is an autogenerated mock type for the Logger type
type MockLogger struct {
	mock.Mock
}

type MockLogger_Expecter struct {
	mock *mock.Mock
}

func (_m *MockLogger) EXPECT() *MockLogger_Expecter {
	return &MockLogger_Expecter{mock: &_m.Mock}
}

// Debug provides a mock function for the type MockLogger
func (_mock *MockLogger) Debug(msg string, fields ...interface{}) {
	if len(fields) > 0 {
		_mock.Called(msg, fields)
	} else {
		_mock.Called(msg)
	}

	return
}

// MockLogger_Debug_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Debug'
type MockLogger_Debug_Call struct {
	*mock.Call
}

// Debug is a helper method to define mock.On call
//   - msg string
//   - fields ...interface{}
func (_e *MockLogger_Expecter) Debug(msg interface{}, fields ...interface{}) *MockLogger_Debug_Call {
	return &MockLogger_Debug_Call{Call: _e.mock.On("Debug",
		append([]interface{}{msg}, fields...)...)}
}

func (_c *MockLogger_Debug_Call) Run(run func(msg string, fields ...interface{})) *MockLogger_Debug_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []interface{}
		var variadicArgs []interface{}
		if len(args) > 1 {
			variadicArgs = args[1].([]interface{})
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *MockLogger_Debug_Call) Return() *MockLogger_Debug_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLogger_Debug_Call) RunAndReturn(run func(msg string, fields ...interface{})) *MockLogger_Debug_Call {
	_c.Run(run)
	return _c
}

// Error provides a mock function for the type MockLogger
func (_mock *MockLogger) Error(err error, msg string, fields ...interface{}) {
	if len(fields) > 0 {
		_mock.Called(err, msg, fields)
	} else {
		_mock.Called(err, msg)
	}

	return
}

// MockLogger_Error_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Error'
type MockLogger_Error_Call struct {
	*mock.Call
}

// Error is a helper method to define mock.On call
//   - err error
//   - msg string
//   - fields ...interface{}
func (_e *MockLogger_Expecter) Error(err interface{}, msg interface{}, fields ...interface{}) *MockLogger_Error_Call {
	return &MockLogger_Error_Call{Call: _e.mock.On("Error",
		append([]interface{}{err, msg}, fields...)...)}
}

func (_c *MockLogger_Error_Call) Run(run func(err error, msg string, fields ...interface{})) *MockLogger_Error_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 error
		if args[0] != nil {
			arg0 = args[0].(error)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 []interface{}
		var variadicArgs []interface{}
		if len(args) > 2 {
			variadicArgs = args[2].([]interface{})
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockLogger_Error_Call) Return() *MockLogger_Error_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLogger_Error_Call) RunAndReturn(run func(err error, msg string, fields ...interface{})) *MockLogger_Error_Call {
	_c.Run(run)
	return _c
}

// Info provides a mock function for the type MockLogger
func (_mock *MockLogger) Info(msg string, fields ...interface{}) {
	if len(fields) > 0 {
		_mock.Called(msg, fields)
	} else {
		_mock.Called(msg)
	}

	return
}

// MockLogger_Info_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Info'
type MockLogger_Info_Call struct {
	*mock.Call
}

// Info is a helper method to define mock.On call
//   - msg string
//   - fields ...interface{}
func (_e *MockLogger_Expecter) Info(msg interface{}, fields ...interface{}) *MockLogger_Info_Call {
	return &MockLogger_Info_Call{Call: _e.mock.On("Info",
		append([]interface{}{msg}, fields...)...)}
}

func (_c *MockLogger_Info_Call) Run(run func(msg string, fields ...interface{})) *MockLogger_Info_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []interface{}
		var variadicArgs []interface{}
		if len(args) > 1 {
			variadicArgs = args[1].([]interface{})
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *MockLogger_Info_Call) Return() *MockLogger_Info_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLogger_Info_Call) RunAndReturn(run func(msg string, fields ...interface{})) *MockLogger_Info_Call {
	_c.Run(run)
	return _c
}

// Warn provides a mock function for the type MockLogger
func (_mock *MockLogger) Warn(msg string, fields ...interface{}) {
	if len(fields) > 0 {
		_mock.Called(msg, fields)
	} else {
		_mock.Called(msg)
	}

	return
}

// MockLogger_Warn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Warn'
type MockLogger_Warn_Call struct {
	*mock.Call
}

// Warn is a helper method to define mock.On call
//   - msg string
//   - fields ...interface{}
func (_e *MockLogger_Expecter) Warn(msg interface{}, fields ...interface{}) *MockLogger_Warn_Call {
	return &MockLogger_Warn_Call{Call: _e.mock.On("Warn",
		append([]interface{}{msg}, fields...)...)}
}

func (_c *MockLogger_Warn_Call) Run(run func(msg string, fields ...interface{})) *MockLogger_Warn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 []interface{}
		var variadicArgs []interface{}
		if len(args) > 1 {
			variadicArgs = args[1].([]interface{})
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *MockLogger_Warn_Call) Return() *MockLogger_Warn_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLogger_Warn_Call) RunAndReturn(run func(msg string, fields ...interface{})) *MockLogger_Warn_Call {
	_c.Run(run)
	return _c
}
